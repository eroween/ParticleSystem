#include	<iostream>
#include	"ParticleSystem.hpp"
#include	"Opengl3DRenderer.hpp"
#include	"SphereShape.hpp"

namespace	ParticleSystem
{

  //----------------------------------------
  // Constructor
  // @param :
  // maxParticles represent the maximum particle number that can be draw in the same time.
  //----------------------------------------
  ParticleSystem::ParticleSystem(const glm::vec3 &position, const glm::vec3 &rotation,
				 const glm::vec3 &scale, unsigned int maxParticles) :
    _position(position),
    _rotation(rotation),
    _scale(scale),
    _maxParticles(maxParticles),
    _renderer(0)
  {
    this->_renderer = new Opengl3DRenderer();
    this->_shape = new SphereShape();
    this->emit(1);
  }

  //----------------------------------------
  // Destructor
  //----------------------------------------
  ParticleSystem::~ParticleSystem(void)
  {
    delete this->_renderer;
  }

  //----------------------------------------
  // Update is the function you need to call each frame with the time elapsed
  // between the two last frame for update particle position in the scene.
  //
  // Thread safe
  //----------------------------------------
  void
  ParticleSystem::update(float elapsedTime)
  {
    // std::cout << "particles used : " << this->_particles.size() << std::endl;
    // std::cout << "particles unused : " << this->_unusedParticles.size() << std::endl;

    for (std::list<Particle *>::iterator it = this->_particles.begin() ; it != this->_particles.end() ; ++it)
      {
	(*it)->update(elapsedTime);
      }
  }

  //--------------------------------------------------------------------------------
  // draw is the function you need to call when you want to render the particle system
  // in the scene.
  // 
  // @param:
  // projection : represent the matrix generated by a glm::perspective or glm::orthographic
  // modelview : represent the referencial matrix used to position the particle system in the world.
  // 
  // Thread safe
  //--------------------------------------------------------------------------------
  void
  ParticleSystem::draw(const glm::mat4 &projection, const glm::mat4 &modelview, const glm::vec3 &camPosition)
  {
    std::vector<float>	vertex;

    if (this->_particles.empty())
      return;
    for (std::list<Particle *>::iterator it = this->_particles.begin() ; it != this->_particles.end() ; ++it)
      {
	(*it)->draw(camPosition, vertex);
      }
    this->_renderer->draw(projection, modelview, vertex);
  }

  //----------------------------------------
  // Emit is used to emit particles in the scene manually.
  //----------------------------------------
  void
  ParticleSystem::emit(int numberParticles)
  {
    glm::vec3	position, force;
    Particle	*newParticle;

    while (numberParticles > 0 && this->_maxParticles != this->_particles.size())
      {
	this->_shape->apply(position, force);
	newParticle = new Particle(position);
	newParticle->setLifetime(5.0f);
	newParticle->setForce(force);
	this->_particles.push_back(newParticle);
	--numberParticles;
      }
  }

  //----------------------------------------
  // 
  //----------------------------------------
  void
  ParticleSystem::reinit(void)
  {
    for (std::list<Particle *>::iterator it = this->_particles.begin() ; it != this->_particles.end() ; )
      {
	if ((*it)->isAlive() == false)
	  {
	    this->_unusedParticles.push_back((*it));
	    it = this->_particles.erase(it);
	  }
	else
	  {
	    ++it;
	  }
      }
  }

}
